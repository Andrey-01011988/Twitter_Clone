# pytest -s tests/test_application.py
=================================================================================================== test session starts ===================================================================================================
platform linux -- Python 3.11.11, pytest-8.3.3, pluggy-1.5.0
rootdir: /server/tests
configfile: pytest.ini
plugins: asyncio-0.24.0, Faker-30.8.2, anyio-4.6.2.post1
asyncio: mode=Mode.AUTO, default_loop_scope=module
collected 1 item

tests/test_application.py Запуск фикстуры
2024-12-23 14:45:27,801 INFO sqlalchemy.engine.Engine select pg_catalog.version()
2024-12-23 14:45:27,801 INFO sqlalchemy.engine.Engine [raw sql] ()
2024-12-23 14:45:27,803 INFO sqlalchemy.engine.Engine select current_schema()
2024-12-23 14:45:27,803 INFO sqlalchemy.engine.Engine [raw sql] ()
2024-12-23 14:45:27,804 INFO sqlalchemy.engine.Engine show standard_conforming_strings
2024-12-23 14:45:27,804 INFO sqlalchemy.engine.Engine [raw sql] ()
2024-12-23 14:45:27,806 INFO sqlalchemy.engine.Engine BEGIN (implicit)
Начало
2024-12-23 14:45:27,810 INFO sqlalchemy.engine.Engine SELECT pg_catalog.pg_class.relname
FROM pg_catalog.pg_class JOIN pg_catalog.pg_namespace ON pg_catalog.pg_namespace.oid = pg_catalog.pg_class.relnamespace
WHERE pg_catalog.pg_class.relname = $1::VARCHAR AND pg_catalog.pg_class.relkind = ANY (ARRAY[$2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR]) AND pg_catalog.pg_table_is_visible(pg_catalog.pg_class.oid) AND pg_catalog.pg_namespace.nspname != $7::VARCHAR
2024-12-23 14:45:27,810 INFO sqlalchemy.engine.Engine [generated in 0.00026s] ('followers', 'r', 'p', 'f', 'v', 'm', 'pg_catalog')
2024-12-23 14:45:27,813 INFO sqlalchemy.engine.Engine SELECT pg_catalog.pg_class.relname
FROM pg_catalog.pg_class JOIN pg_catalog.pg_namespace ON pg_catalog.pg_namespace.oid = pg_catalog.pg_class.relnamespace
WHERE pg_catalog.pg_class.relname = $1::VARCHAR AND pg_catalog.pg_class.relkind = ANY (ARRAY[$2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR]) AND pg_catalog.pg_table_is_visible(pg_catalog.pg_class.oid) AND pg_catalog.pg_namespace.nspname != $7::VARCHAR
2024-12-23 14:45:27,813 INFO sqlalchemy.engine.Engine [cached since 0.003167s ago] ('users', 'r', 'p', 'f', 'v', 'm', 'pg_catalog')
2024-12-23 14:45:27,814 INFO sqlalchemy.engine.Engine SELECT pg_catalog.pg_class.relname
FROM pg_catalog.pg_class JOIN pg_catalog.pg_namespace ON pg_catalog.pg_namespace.oid = pg_catalog.pg_class.relnamespace
WHERE pg_catalog.pg_class.relname = $1::VARCHAR AND pg_catalog.pg_class.relkind = ANY (ARRAY[$2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR]) AND pg_catalog.pg_table_is_visible(pg_catalog.pg_class.oid) AND pg_catalog.pg_namespace.nspname != $7::VARCHAR
2024-12-23 14:45:27,814 INFO sqlalchemy.engine.Engine [cached since 0.004119s ago] ('tweets', 'r', 'p', 'f', 'v', 'm', 'pg_catalog')
2024-12-23 14:45:27,815 INFO sqlalchemy.engine.Engine SELECT pg_catalog.pg_class.relname
FROM pg_catalog.pg_class JOIN pg_catalog.pg_namespace ON pg_catalog.pg_namespace.oid = pg_catalog.pg_class.relnamespace
WHERE pg_catalog.pg_class.relname = $1::VARCHAR AND pg_catalog.pg_class.relkind = ANY (ARRAY[$2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR]) AND pg_catalog.pg_table_is_visible(pg_catalog.pg_class.oid) AND pg_catalog.pg_namespace.nspname != $7::VARCHAR
2024-12-23 14:45:27,815 INFO sqlalchemy.engine.Engine [cached since 0.004981s ago] ('likes', 'r', 'p', 'f', 'v', 'm', 'pg_catalog')
2024-12-23 14:45:27,816 INFO sqlalchemy.engine.Engine SELECT pg_catalog.pg_class.relname
FROM pg_catalog.pg_class JOIN pg_catalog.pg_namespace ON pg_catalog.pg_namespace.oid = pg_catalog.pg_class.relnamespace
WHERE pg_catalog.pg_class.relname = $1::VARCHAR AND pg_catalog.pg_class.relkind = ANY (ARRAY[$2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR]) AND pg_catalog.pg_table_is_visible(pg_catalog.pg_class.oid) AND pg_catalog.pg_namespace.nspname != $7::VARCHAR
2024-12-23 14:45:27,816 INFO sqlalchemy.engine.Engine [cached since 0.005851s ago] ('media', 'r', 'p', 'f', 'v', 'm', 'pg_catalog')
Тестовая б/д создана
2024-12-23 14:45:27,817 INFO sqlalchemy.engine.Engine COMMIT
Текущая сессия: <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x795e15c08450>
2024-12-23 14:45:27,831 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2024-12-23 14:45:27,833 INFO sqlalchemy.engine.Engine INSERT INTO users (name, api_key) SELECT p0::VARCHAR, p1::VARCHAR FROM (VALUES ($1::VARCHAR, $2::VARCHAR, 0), ($3::VARCHAR, $4::VARCHAR, 1), ($5::VARCHAR, $6::VARCHAR, 2)) AS imp_sen(p0, p1, sen_counter) ORDER BY sen_counter RETURNING users.id, users.id AS id__1
2024-12-23 14:45:27,834 INFO sqlalchemy.engine.Engine [generated in 0.00012s (insertmanyvalues) 1/1 (ordered)] ('Фрол Яковлевич Козлов', 'test', 'Ульян Марсович Федосеев', 'Is964r72', 'Лора Тимофеевна Фадеева', 'wq136o59')
2024-12-23 14:45:27,836 INFO sqlalchemy.engine.Engine ROLLBACK
2024-12-23 14:45:27,837 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2024-12-23 14:45:27,838 INFO sqlalchemy.engine.Engine SELECT pg_catalog.pg_class.relname
FROM pg_catalog.pg_class JOIN pg_catalog.pg_namespace ON pg_catalog.pg_namespace.oid = pg_catalog.pg_class.relnamespace
WHERE pg_catalog.pg_class.relname = $1::VARCHAR AND pg_catalog.pg_class.relkind = ANY (ARRAY[$2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR]) AND pg_catalog.pg_table_is_visible(pg_catalog.pg_class.oid) AND pg_catalog.pg_namespace.nspname != $7::VARCHAR
2024-12-23 14:45:27,838 INFO sqlalchemy.engine.Engine [cached since 0.02809s ago] ('followers', 'r', 'p', 'f', 'v', 'm', 'pg_catalog')
2024-12-23 14:45:27,842 INFO sqlalchemy.engine.Engine SELECT pg_catalog.pg_class.relname
FROM pg_catalog.pg_class JOIN pg_catalog.pg_namespace ON pg_catalog.pg_namespace.oid = pg_catalog.pg_class.relnamespace
WHERE pg_catalog.pg_class.relname = $1::VARCHAR AND pg_catalog.pg_class.relkind = ANY (ARRAY[$2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR]) AND pg_catalog.pg_table_is_visible(pg_catalog.pg_class.oid) AND pg_catalog.pg_namespace.nspname != $7::VARCHAR
2024-12-23 14:45:27,842 INFO sqlalchemy.engine.Engine [cached since 0.03228s ago] ('users', 'r', 'p', 'f', 'v', 'm', 'pg_catalog')
2024-12-23 14:45:27,843 INFO sqlalchemy.engine.Engine SELECT pg_catalog.pg_class.relname
FROM pg_catalog.pg_class JOIN pg_catalog.pg_namespace ON pg_catalog.pg_namespace.oid = pg_catalog.pg_class.relnamespace
WHERE pg_catalog.pg_class.relname = $1::VARCHAR AND pg_catalog.pg_class.relkind = ANY (ARRAY[$2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR]) AND pg_catalog.pg_table_is_visible(pg_catalog.pg_class.oid) AND pg_catalog.pg_namespace.nspname != $7::VARCHAR
2024-12-23 14:45:27,844 INFO sqlalchemy.engine.Engine [cached since 0.03339s ago] ('tweets', 'r', 'p', 'f', 'v', 'm', 'pg_catalog')
2024-12-23 14:45:27,844 INFO sqlalchemy.engine.Engine SELECT pg_catalog.pg_class.relname
FROM pg_catalog.pg_class JOIN pg_catalog.pg_namespace ON pg_catalog.pg_namespace.oid = pg_catalog.pg_class.relnamespace
WHERE pg_catalog.pg_class.relname = $1::VARCHAR AND pg_catalog.pg_class.relkind = ANY (ARRAY[$2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR]) AND pg_catalog.pg_table_is_visible(pg_catalog.pg_class.oid) AND pg_catalog.pg_namespace.nspname != $7::VARCHAR
2024-12-23 14:45:27,844 INFO sqlalchemy.engine.Engine [cached since 0.0343s ago] ('likes', 'r', 'p', 'f', 'v', 'm', 'pg_catalog')
2024-12-23 14:45:27,845 INFO sqlalchemy.engine.Engine SELECT pg_catalog.pg_class.relname
FROM pg_catalog.pg_class JOIN pg_catalog.pg_namespace ON pg_catalog.pg_namespace.oid = pg_catalog.pg_class.relnamespace
WHERE pg_catalog.pg_class.relname = $1::VARCHAR AND pg_catalog.pg_class.relkind = ANY (ARRAY[$2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR]) AND pg_catalog.pg_table_is_visible(pg_catalog.pg_class.oid) AND pg_catalog.pg_namespace.nspname != $7::VARCHAR
2024-12-23 14:45:27,846 INFO sqlalchemy.engine.Engine [cached since 0.03548s ago] ('media', 'r', 'p', 'f', 'v', 'm', 'pg_catalog')
2024-12-23 14:45:27,847 INFO sqlalchemy.engine.Engine
DROP TABLE media
2024-12-23 14:45:27,847 INFO sqlalchemy.engine.Engine [no key 0.00027s] ()
2024-12-23 14:45:27,850 INFO sqlalchemy.engine.Engine
DROP TABLE likes
2024-12-23 14:45:27,850 INFO sqlalchemy.engine.Engine [no key 0.00024s] ()
2024-12-23 14:45:27,851 INFO sqlalchemy.engine.Engine
DROP TABLE tweets
2024-12-23 14:45:27,851 INFO sqlalchemy.engine.Engine [no key 0.00015s] ()
2024-12-23 14:45:27,854 INFO sqlalchemy.engine.Engine
DROP TABLE followers
2024-12-23 14:45:27,854 INFO sqlalchemy.engine.Engine [no key 0.00017s] ()
2024-12-23 14:45:27,857 INFO sqlalchemy.engine.Engine
DROP TABLE users
2024-12-23 14:45:27,858 INFO sqlalchemy.engine.Engine [no key 0.00063s] ()
2024-12-23 14:45:27,859 INFO sqlalchemy.engine.Engine COMMIT
E

========================================================================================================= ERRORS ==========================================================================================================
____________________________________________________________________________________________ ERROR at setup of test_all_users _____________________________________________________________________________________________

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x795e154e62c0>
operation = 'INSERT INTO users (name, api_key) SELECT p0::VARCHAR, p1::VARCHAR FROM (VALUES ($1::VARCHAR, $2::VARCHAR, 0), ($3::VA...::VARCHAR, $6::VARCHAR, 2)) AS imp_sen(p0, p1, sen_counter) ORDER BY sen_counter RETURNING users.id, users.id AS id__1'
parameters = ('Фрол Яковлевич Козлов', 'test', 'Ульян Марсович Федосеев', 'Is964r72', 'Лора Тимофеевна Фадеева', 'wq136o59')

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None

                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:534:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.11/site-packages/asyncpg/prepared_stmt.py:176: in fetch
    data = await self.__bind_execute(args, 0, timeout)
/usr/local/lib/python3.11/site-packages/asyncpg/prepared_stmt.py:267: in __bind_execute
    data, status, _ = await self.__do_execute(
/usr/local/lib/python3.11/site-packages/asyncpg/prepared_stmt.py:256: in __do_execute
    return await executor(protocol)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.UniqueViolationError: duplicate key value violates unique constraint "ix_users_api_key"
E   DETAIL:  Key (api_key)=(test) already exists.

asyncpg/protocol/protocol.pyx:206: UniqueViolationError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x795e15536f10>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x795e156fa150>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x795e15537390>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.

        """

        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters = parameters

        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()

        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"

        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0

        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )

            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters

            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )

            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))

                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""

                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"

                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )

            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2118:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/default.py:941: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:568: in execute
    self._adapt_connection.await_(
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:546: in _prepare_and_execute
    self._handle_exception(error)
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:497: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x795e154e05e0>>, error = UniqueViolationError('duplicate key value violates unique constraint "ix_users_api_key"')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.IntegrityError: <class 'asyncpg.exceptions.UniqueViolationError'>: duplicate key value violates unique constraint "ix_users_api_key"
E                   DETAIL:  Key (api_key)=(test) already exists.

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:780: IntegrityError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="module")
    async def setup_database():
        print("Запуск фикстуры")
        async with test_engine.begin() as conn:
            print("Начало")
            try:
                await conn.run_sync(BaseProj.metadata.create_all)
            except Exception as e:
                logger.error(f"Ошибка при создании таблиц: {e}")
                raise
            print("Тестовая б/д создана")

        # Создаем сессию вне контекстного менеджера
        test_session = AsyncSessionTest()
        async with test_session:
            try:
                logger.info("Создание новой тестовой сессии")
                users = []
                UserFactory._meta.sqlalchemy_session = test_session
                print(f"Текущая сессия: {test_session}")

                # Логирование информации о подключении
                connection_info = test_session.bind.url
                logger.info(f"Подключение к базе данных: {connection_info}")

                # Создание пользователей
                for i in range(3):
                    if i == 0:
                        user = UserFactory(api_key='test')
                    else:
                        user = UserFactory()
                    users.append(user)
                test_session.add_all(users)
>               await test_session.commit()

tests/test_application.py:75:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.11/site-packages/sqlalchemy/ext/asyncio/session.py:1009: in commit
    await greenlet_spawn(self.sync_session.commit)
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:203: in greenlet_spawn
    result = context.switch(value)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2028: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4352: in flush
    self._flush(objects)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4487: in _flush
    with util.safe_reraise():
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4448: in _flush
    flush_context.execute()
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/default.py:941: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:568: in execute
    self._adapt_connection.await_(
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:546: in _prepare_and_execute
    self._handle_exception(error)
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:497: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x795e154e05e0>>, error = UniqueViolationError('duplicate key value violates unique constraint "ix_users_api_key"')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.IntegrityError: (sqlalchemy.dialects.postgresql.asyncpg.IntegrityError) <class 'asyncpg.exceptions.UniqueViolationError'>: duplicate key value violates unique constraint "ix_users_api_key"
E                   DETAIL:  Key (api_key)=(test) already exists.
E                   [SQL: INSERT INTO users (name, api_key) SELECT p0::VARCHAR, p1::VARCHAR FROM (VALUES ($1::VARCHAR, $2::VARCHAR, 0), ($3::VARCHAR, $4::VARCHAR, 1), ($5::VARCHAR, $6::VARCHAR, 2)) AS imp_sen(p0, p1, sen_counter) ORDER BY sen_counter RETURNING users.id, users.id AS id__1]
E                   [parameters: ('Фрол Яковлевич Козлов', 'test', 'Ульян Марсович Федосеев', 'Is964r72', 'Лора Тимофеевна Фадеева', 'wq136o59')]
E                   (Background on this error at: https://sqlalche.me/e/20/gkpj)

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:780: IntegrityError
--------------------------------------------------------------------------------------------------- Captured log setup ----------------------------------------------------------------------------------------------------
INFO     sqlalchemy.engine.Engine:base.py:1846 select pg_catalog.version()
INFO     sqlalchemy.engine.Engine:base.py:1846 [raw sql] ()
INFO     sqlalchemy.engine.Engine:base.py:1846 select current_schema()
INFO     sqlalchemy.engine.Engine:base.py:1846 [raw sql] ()
INFO     sqlalchemy.engine.Engine:base.py:1846 show standard_conforming_strings
INFO     sqlalchemy.engine.Engine:base.py:1846 [raw sql] ()
INFO     sqlalchemy.engine.Engine:base.py:2701 BEGIN (implicit)
INFO     sqlalchemy.engine.Engine:base.py:1846 SELECT pg_catalog.pg_class.relname
FROM pg_catalog.pg_class JOIN pg_catalog.pg_namespace ON pg_catalog.pg_namespace.oid = pg_catalog.pg_class.relnamespace
WHERE pg_catalog.pg_class.relname = $1::VARCHAR AND pg_catalog.pg_class.relkind = ANY (ARRAY[$2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR]) AND pg_catalog.pg_table_is_visible(pg_catalog.pg_class.oid) AND pg_catalog.pg_namespace.nspname != $7::VARCHAR
INFO     sqlalchemy.engine.Engine:base.py:1846 [generated in 0.00026s] ('followers', 'r', 'p', 'f', 'v', 'm', 'pg_catalog')
INFO     sqlalchemy.engine.Engine:base.py:1846 SELECT pg_catalog.pg_class.relname
FROM pg_catalog.pg_class JOIN pg_catalog.pg_namespace ON pg_catalog.pg_namespace.oid = pg_catalog.pg_class.relnamespace
WHERE pg_catalog.pg_class.relname = $1::VARCHAR AND pg_catalog.pg_class.relkind = ANY (ARRAY[$2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR]) AND pg_catalog.pg_table_is_visible(pg_catalog.pg_class.oid) AND pg_catalog.pg_namespace.nspname != $7::VARCHAR
INFO     sqlalchemy.engine.Engine:base.py:1846 [cached since 0.003167s ago] ('users', 'r', 'p', 'f', 'v', 'm', 'pg_catalog')
INFO     sqlalchemy.engine.Engine:base.py:1846 SELECT pg_catalog.pg_class.relname
FROM pg_catalog.pg_class JOIN pg_catalog.pg_namespace ON pg_catalog.pg_namespace.oid = pg_catalog.pg_class.relnamespace
WHERE pg_catalog.pg_class.relname = $1::VARCHAR AND pg_catalog.pg_class.relkind = ANY (ARRAY[$2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR]) AND pg_catalog.pg_table_is_visible(pg_catalog.pg_class.oid) AND pg_catalog.pg_namespace.nspname != $7::VARCHAR
INFO     sqlalchemy.engine.Engine:base.py:1846 [cached since 0.004119s ago] ('tweets', 'r', 'p', 'f', 'v', 'm', 'pg_catalog')
INFO     sqlalchemy.engine.Engine:base.py:1846 SELECT pg_catalog.pg_class.relname
FROM pg_catalog.pg_class JOIN pg_catalog.pg_namespace ON pg_catalog.pg_namespace.oid = pg_catalog.pg_class.relnamespace
WHERE pg_catalog.pg_class.relname = $1::VARCHAR AND pg_catalog.pg_class.relkind = ANY (ARRAY[$2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR]) AND pg_catalog.pg_table_is_visible(pg_catalog.pg_class.oid) AND pg_catalog.pg_namespace.nspname != $7::VARCHAR
INFO     sqlalchemy.engine.Engine:base.py:1846 [cached since 0.004981s ago] ('likes', 'r', 'p', 'f', 'v', 'm', 'pg_catalog')
INFO     sqlalchemy.engine.Engine:base.py:1846 SELECT pg_catalog.pg_class.relname
FROM pg_catalog.pg_class JOIN pg_catalog.pg_namespace ON pg_catalog.pg_namespace.oid = pg_catalog.pg_class.relnamespace
WHERE pg_catalog.pg_class.relname = $1::VARCHAR AND pg_catalog.pg_class.relkind = ANY (ARRAY[$2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR]) AND pg_catalog.pg_table_is_visible(pg_catalog.pg_class.oid) AND pg_catalog.pg_namespace.nspname != $7::VARCHAR
INFO     sqlalchemy.engine.Engine:base.py:1846 [cached since 0.005851s ago] ('media', 'r', 'p', 'f', 'v', 'm', 'pg_catalog')
INFO     sqlalchemy.engine.Engine:base.py:2707 COMMIT
INFO     sqlalchemy.engine.Engine:base.py:2701 BEGIN (implicit)
INFO     sqlalchemy.engine.Engine:base.py:1844 INSERT INTO users (name, api_key) SELECT p0::VARCHAR, p1::VARCHAR FROM (VALUES ($1::VARCHAR, $2::VARCHAR, 0), ($3::VARCHAR, $4::VARCHAR, 1), ($5::VARCHAR, $6::VARCHAR, 2)) AS imp_sen(p0, p1, sen_counter) ORDER BY sen_counter RETURNING users.id, users.id AS id__1
INFO     sqlalchemy.engine.Engine:base.py:1844 [generated in 0.00012s (insertmanyvalues) 1/1 (ordered)] ('Фрол Яковлевич Козлов', 'test', 'Ульян Марсович Федосеев', 'Is964r72', 'Лора Тимофеевна Фадеева', 'wq136o59')
INFO     sqlalchemy.engine.Engine:base.py:2704 ROLLBACK
ERROR    server.tests.test_application:test_application.py:124 Ошибка при работе с базой данных: (sqlalchemy.dialects.postgresql.asyncpg.IntegrityError) <class 'asyncpg.exceptions.UniqueViolationError'>: duplicate key value violates unique constraint "ix_users_api_key"
DETAIL:  Key (api_key)=(test) already exists.
[SQL: INSERT INTO users (name, api_key) SELECT p0::VARCHAR, p1::VARCHAR FROM (VALUES ($1::VARCHAR, $2::VARCHAR, 0), ($3::VARCHAR, $4::VARCHAR, 1), ($5::VARCHAR, $6::VARCHAR, 2)) AS imp_sen(p0, p1, sen_counter) ORDER BY sen_counter RETURNING users.id, users.id AS id__1]
[parameters: ('Фрол Яковлевич Козлов', 'test', 'Ульян Марсович Федосеев', 'Is964r72', 'Лора Тимофеевна Фадеева', 'wq136o59')]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
INFO     sqlalchemy.engine.Engine:base.py:2701 BEGIN (implicit)
INFO     sqlalchemy.engine.Engine:base.py:1846 SELECT pg_catalog.pg_class.relname
FROM pg_catalog.pg_class JOIN pg_catalog.pg_namespace ON pg_catalog.pg_namespace.oid = pg_catalog.pg_class.relnamespace
WHERE pg_catalog.pg_class.relname = $1::VARCHAR AND pg_catalog.pg_class.relkind = ANY (ARRAY[$2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR]) AND pg_catalog.pg_table_is_visible(pg_catalog.pg_class.oid) AND pg_catalog.pg_namespace.nspname != $7::VARCHAR
INFO     sqlalchemy.engine.Engine:base.py:1846 [cached since 0.02809s ago] ('followers', 'r', 'p', 'f', 'v', 'm', 'pg_catalog')
INFO     sqlalchemy.engine.Engine:base.py:1846 SELECT pg_catalog.pg_class.relname
FROM pg_catalog.pg_class JOIN pg_catalog.pg_namespace ON pg_catalog.pg_namespace.oid = pg_catalog.pg_class.relnamespace
WHERE pg_catalog.pg_class.relname = $1::VARCHAR AND pg_catalog.pg_class.relkind = ANY (ARRAY[$2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR]) AND pg_catalog.pg_table_is_visible(pg_catalog.pg_class.oid) AND pg_catalog.pg_namespace.nspname != $7::VARCHAR
INFO     sqlalchemy.engine.Engine:base.py:1846 [cached since 0.03228s ago] ('users', 'r', 'p', 'f', 'v', 'm', 'pg_catalog')
INFO     sqlalchemy.engine.Engine:base.py:1846 SELECT pg_catalog.pg_class.relname
FROM pg_catalog.pg_class JOIN pg_catalog.pg_namespace ON pg_catalog.pg_namespace.oid = pg_catalog.pg_class.relnamespace
WHERE pg_catalog.pg_class.relname = $1::VARCHAR AND pg_catalog.pg_class.relkind = ANY (ARRAY[$2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR]) AND pg_catalog.pg_table_is_visible(pg_catalog.pg_class.oid) AND pg_catalog.pg_namespace.nspname != $7::VARCHAR
INFO     sqlalchemy.engine.Engine:base.py:1846 [cached since 0.03339s ago] ('tweets', 'r', 'p', 'f', 'v', 'm', 'pg_catalog')
INFO     sqlalchemy.engine.Engine:base.py:1846 SELECT pg_catalog.pg_class.relname
FROM pg_catalog.pg_class JOIN pg_catalog.pg_namespace ON pg_catalog.pg_namespace.oid = pg_catalog.pg_class.relnamespace
WHERE pg_catalog.pg_class.relname = $1::VARCHAR AND pg_catalog.pg_class.relkind = ANY (ARRAY[$2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR]) AND pg_catalog.pg_table_is_visible(pg_catalog.pg_class.oid) AND pg_catalog.pg_namespace.nspname != $7::VARCHAR
INFO     sqlalchemy.engine.Engine:base.py:1846 [cached since 0.0343s ago] ('likes', 'r', 'p', 'f', 'v', 'm', 'pg_catalog')
INFO     sqlalchemy.engine.Engine:base.py:1846 SELECT pg_catalog.pg_class.relname
FROM pg_catalog.pg_class JOIN pg_catalog.pg_namespace ON pg_catalog.pg_namespace.oid = pg_catalog.pg_class.relnamespace
WHERE pg_catalog.pg_class.relname = $1::VARCHAR AND pg_catalog.pg_class.relkind = ANY (ARRAY[$2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR]) AND pg_catalog.pg_table_is_visible(pg_catalog.pg_class.oid) AND pg_catalog.pg_namespace.nspname != $7::VARCHAR
INFO     sqlalchemy.engine.Engine:base.py:1846 [cached since 0.03548s ago] ('media', 'r', 'p', 'f', 'v', 'm', 'pg_catalog')
INFO     sqlalchemy.engine.Engine:base.py:1846
DROP TABLE media
INFO     sqlalchemy.engine.Engine:base.py:1846 [no key 0.00027s] ()
INFO     sqlalchemy.engine.Engine:base.py:1846
DROP TABLE likes
INFO     sqlalchemy.engine.Engine:base.py:1846 [no key 0.00024s] ()
INFO     sqlalchemy.engine.Engine:base.py:1846
DROP TABLE tweets
INFO     sqlalchemy.engine.Engine:base.py:1846 [no key 0.00015s] ()
INFO     sqlalchemy.engine.Engine:base.py:1846
DROP TABLE followers
INFO     sqlalchemy.engine.Engine:base.py:1846 [no key 0.00017s] ()
INFO     sqlalchemy.engine.Engine:base.py:1846
DROP TABLE users
INFO     sqlalchemy.engine.Engine:base.py:1846 [no key 0.00063s] ()
INFO     sqlalchemy.engine.Engine:base.py:2707 COMMIT
================================================================================================= short test summary info =================================================================================================
ERROR tests/test_application.py::test_all_users - sqlalchemy.exc.IntegrityError: (sqlalchemy.dialects.postgresql.asyncpg.IntegrityError) <class 'asyncpg.exceptions.UniqueViolationError'>: duplicate key value violates unique constraint "ix_users_api_key"
==================================================================================================== 1 error in 1.29s =====================================================================================================
#
